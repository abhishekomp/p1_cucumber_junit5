# json-unit Usage Steps for Beginners

Let’s take this **step by step** for a beginner. We’ll:

1. **Explain what [json-unit](https://github.com/lukas-krecan/JsonUnit) is** and why it’s so useful for “golden master” (template) JSON matching.
2. **Show a simple comparison example using json-unit.**
3. **Introduce a custom golden master** (your placeholder JSON with ignore/matchers).
4. **Show, step by step, how to code the comparison**: loading files, running the match, and interpreting results.
5. **Demonstrate with a full Java test example, including custom matchers.**

---

## **1. What is json-unit?**

**json-unit** is a Java library that lets you compare JSON documents in test assertions. It’s **smarter than just comparing strings**:
- Ignores order if desired.
- Ignores paths/fields you specify.
- Allows custom **matchers** for dynamic fields (e.g., timestamps, IDs, tokens) that can’t or shouldn’t be strictly compared.
- Lets you use templates containing `${json-unit.ignore}` or `${json-unit.matches:someMatcher}` as field values.
- It’s used in tests to compare *actual* JSON output to a *golden master* (expected template), passing if all fields match (with custom flexibility).

**Example**: You want to confirm the `"name"` and `"roles"` fields in a JSON API response are stable, but `"createdAt"` is generated by the backend and should just be present (not strictly compared).

---

## **2. Simple json-unit Example**

**Dependencies:**  
Add to your Maven pom.xml:
```xml
<dependency>
  <groupId>net.javacrumbs.json-unit</groupId>
  <artifactId>json-unit-assertj</artifactId>
  <version>3.2.7</version>
  <scope>test</scope>
</dependency>
```

**Note:**  
You might encounter an error like this when running the code:

```
Caused by: java.lang.IllegalStateException: Please add either json.org, Jackson 1.x, Jackson 2.x, Johnzon or Gson to the classpath
```
This error occurs because the JsonUnit library (used via assertThatJson) requires a JSON parser implementation to be present on the classpath to parse and compare JSON strings. JsonUnit supports several popular JSON libraries, such as Jackson, Gson, or org.json, but none of these are currently available in your project's dependencies.
This means that when you try to use `assertThatJson`, JsonUnit cannot parse the JSON strings because it doesn't know how to handle them without a JSON library.
To fix this, you need to add one of the supported JSON libraries (e.g., Jackson or Gson) to your project's dependencies (typically in your pom.xml if you are using Maven). Once you add a supported JSON library, JsonUnit will be able to parse the JSON and the error will be resolved.
```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.17.1</version>
    <scope>test</scope>
</dependency>
```

**Code:**
```java
import static net.javacrumbs.jsonunit.assertj.JsonAssertions.assertThatJson;

public class JsonUnitSimpleExample {
    public static void main(String[] args) {
        String expected = """
        {
            "name": "Alice",
            "id": "${json-unit.ignore}"
        }
        """;
        String actual = """
        {
            "name": "Alice",
            "id": "ANY_DYNAMIC_VALUE"
        }
        """;
        assertThatJson(actual).isEqualTo(expected); // Passes, id is ignored!
    }
}
```
- `"id"` can be any value in the actual JSON.

---

## **3. Step-by-Step: Custom Golden Master with Ignore/Matchers**

Let’s create a golden master with custom matchers and show how to do the matching in Java.

### **A. Golden Master JSON (Template)**

```json
{
  "userId": "${json-unit.matches:idMatcher}",
  "createdAt": "${json-unit.ignore}",
  "profile": {
    "name": "Charlie",
    "status": "${json-unit.matches:statusMatcher}",
    "registrationTimestamp": "${json-unit.matches:timestampMatcher}"
  }
}
```

### **B. Example API Response**

```json
{
  "userId": "U1001-2025",
  "createdAt": "2026-01-02T10:15:30Z",
  "profile": {
    "name": "Charlie",
    "status": "PENDING",
    "registrationTimestamp": "2026-01-02T09:55:00Z"
  }
}
```

---

### **C. Registering Custom Matchers in json-unit**

json-unit allows you to create **custom Java code** (called matchers) for `${json-unit.matches:...}`.

**Example:**
- `idMatcher`: Checks user IDs are “U” followed by digits and a year.
- `statusMatcher`: Allows only "PENDING" or "ACTIVE".
- `timestampMatcher`: Checks string is valid ISO-8601 timestamp.

---

### **D. Java Implementation — Step by Step**

#### **1. Implement the Custom Matchers**

```java
import net.javacrumbs.jsonunit.core.internal.matchers.JsonMatcher;
import net.javacrumbs.jsonunit.core.internal.matchers.MatchesPatternJsonMatcher;
import java.util.regex.Pattern;

public class CustomJsonMatchers {
    // idMatcher: "U" followed by digits, hyphen, and year like "2025"
    public static final JsonMatcher ID_MATCHER = new MatchesPatternJsonMatcher(Pattern.compile("U\\d+-20\\d{2}"));
    
    // statusMatcher: only "PENDING" or "ACTIVE"
    public static final JsonMatcher STATUS_MATCHER = actual ->
        "PENDING".equals(actual.asText()) || "ACTIVE".equals(actual.asText())
        ? null : "Status must be PENDING or ACTIVE";
    
    // timestampMatcher: must match ISO-8601 format
    public static final JsonMatcher TIMESTAMP_MATCHER = actual ->
        actual.asText().matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z")
        ? null : "Not a valid ISO-8601 timestamp";
}
```

#### **2. Register Custom Matchers**

With AssertJ and json-unit:

```java
import static net.javacrumbs.jsonunit.assertj.JsonAssertions.assertThatJson;
import net.javacrumbs.jsonunit.core.Option;
import java.util.Map;

public class GoldenMasterComparison {
    public static void check(String actual, String expected) {
        assertThatJson(actual)
            .withMatcher("idMatcher", CustomJsonMatchers.ID_MATCHER)
            .withMatcher("statusMatcher", CustomJsonMatchers.STATUS_MATCHER)
            .withMatcher("timestampMatcher", CustomJsonMatchers.TIMESTAMP_MATCHER)
            .when(Option.IGNORING_EXTRA_FIELDS) // Optional: ignore extra fields in actual that aren't in expected
            .isEqualTo(expected);
    }
}
```

#### **3. Test Case (JUnit 5 Style)**

```java
import org.junit.jupiter.api.Test;

public class GoldenMasterComparisonTest {
    @Test
    void testPositiveGoldenMasterComparison() {
        String expected = """
        {
          "userId": "${json-unit.matches:idMatcher}",
          "createdAt": "${json-unit.ignore}",
          "profile": {
            "name": "Charlie",
            "status": "${json-unit.matches:statusMatcher}",
            "registrationTimestamp": "${json-unit.matches:timestampMatcher}"
          }
        }
        """;
        String actual = """
        {
          "userId": "U1001-2025",
          "createdAt": "2027-03-21T10:01:00Z",
          "profile": {
            "name": "Charlie",
            "status": "PENDING",
            "registrationTimestamp": "2027-03-21T10:01:00Z"
          },
          "extraField": "shouldBeIgnored"
        }
        """;
        GoldenMasterComparison.check(actual, expected);
    }

    @Test
    void testNegativeGoldenMasterComparison() {
        String expected = """
        {
          "userId": "${json-unit.matches:idMatcher}",
          "createdAt": "${json-unit.ignore}",
          "profile": {
            "name": "Charlie",
            "status": "${json-unit.matches:statusMatcher}",
            "registrationTimestamp": "${json-unit.matches:timestampMatcher}"
          }
        }
        """;
        String actual = """
        {
          "userId": "BADVALUE",
          "createdAt": "2027-03-21T10:01:00Z",
          "profile": {
            "name": "Charlie",
            "status": "DEACTIVATED",
            "registrationTimestamp": "wrongFormat"
          }
        }
        """;
        org.junit.jupiter.api.Assertions.assertThrows(
          AssertionError.class,
          () -> GoldenMasterComparison.check(actual, expected)
        );
    }
}
```

---

## **4. Recap and Best Practices**

- **json-unit** lets your expected JSON express exactly which fields to: compare strictly, ignore, or validate via custom rules.
- Custom matchers are tiny bits of Java logic for each placeholder type.
- This gives you robust, maintainable "golden master" testing for any API—every stable field is checked strictly, while dynamic fields are checked intelligently.

